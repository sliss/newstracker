// Steven Liss// using support classes from Princeton's COS 126 intro CS class// TextGenerator client for Markov chain programpackage coreservlets;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class TextGenerator {		private int numSpeaker = 2;	private int k = 5; // order of Markov chain	private int c = 4; // phase constant c determines probability of phase change given parallel nodes, with probability 1/c	//private int m = 3000; // how many chars of new text to create (3000 should easily be plenty)	private int numQuotes; // number of quotes to return	private int[] lengths; // length of each input text	private MarkovChain[] chains;	private String[] inputs; // array of input texts	private String[] quotes; // array to hold output quotes		// generate and return an String array of quotes	public String[] generate(String s1, String s2, int numQ) {// params can me changed to String[] for 3+ speakers				numQuotes = numQ;				quotes = new String[numQuotes];		inputs = new String[numSpeaker];		inputs[0] = s1; inputs[1] = s2;				 //[speaker]		chains = new MarkovChain[numSpeaker];		chains[0] = new MarkovChain();		chains[1] = new MarkovChain();		        lengths = new int[2];                for(int speaker = 0; speaker < numSpeaker; speaker++) { // for each speaker...        	lengths[speaker] = inputs[speaker].length();        	inputs[speaker] += inputs[speaker].substring(0, 20 * k); // make cyclical string with extra buffer at end        }                for(int i = 0; i < numQuotes; i++) { // generate numQuotes (default 10) quotes        	quotes[i] = generateQuote();        }                /*	        for(int i = 0; i < lengths[speaker] - k - 20; i++) { // create each chain, stopping safely before end        		for(int kMod = 0; kMod < 3; kMod++) // for each modification to k: 0,+1 +2...        			for(int j = 0; j < 3; j++) {        				//System.out.println(inputs[speaker].substring(i, i + k + kMod) + "->" + inputs[speaker].substring(i + k + kMod, (i + k + kMod) + k + j));        				chains[speaker].addTransition(inputs[speaker].substring(i, i + k + kMod),        					inputs[speaker].substring(i + k + kMod, (i + k + kMod) + k + j));        			}       		}        }     		// build the output.        int startChain = (int)(Math.random() % numSpeaker); // pick a chain to start with        int startIndex = (int)(Math.random() * (lengths[startChain] - 2)); // random starting place at least 1 char before end (assumes string longer than 3 char)                while(!inputs[startChain].substring(startIndex,startIndex + 1).matches("[A-Z]")) {// while tail doesn't start with a capital letter        	startIndex = (int)(Math.random() * lengths[startChain]); // try another starting spot        }                String tail = inputs[startChain].substring(startIndex, startIndex + k); // the tail character-chunk of the output string        String output = new String(tail);				int activeChain = startChain; // numerical attempt at switching active chains		String littleTail = "";					    		//output complete.  now for some string processing to make it nice for viewing			output = output.substring(0,output.lastIndexOf("}")+1); // cut output off at its last quote-end		String potentialQuote = "";		int startQ, endQ = 0, keepers = 0;        		while(keepers < numQuotes && output.contains("}")) { // harvest numQuotes full quotes and store them in a String array			//System.out.println(keepers);			endQ = 0;			startQ = endQ;			endQ = output.indexOf('}', endQ);			potentialQuote = output.substring(startQ, endQ + 1);			//System.out.println(potentialQuote);						if(potentialQuote.contains("*")) {// if potential quote is a mix of the two speakers				quotes[keepers] = potentialQuote.substring(0, potentialQuote.length() - 1);				keepers++;			}						output = output.substring(endQ + 1);		}		if(keepers < numQuotes)			System.out.println("WARNING: ONLY " + keepers + "KEEPERS!!!");        //System.out.println(output);         *          */		return quotes;    }   		public String generateQuote() {		String q1 = "", q2 = ""; // first and second parts of finished quote 		//boolean finished = false;		boolean spliced = false;		int startChain = (int)(Math.random() * 10) % numSpeaker; // pick a chain to start with	    int startIndex = (int)(Math.random() * (lengths[startChain] - 2)); // random starting place at least 1 char before end (assumes string longer than 3 char)	    /*System.out.println("L0 = " + lengths[0] + " L1 = " + lengths[1]);	    System.out.println("startChain = " + startChain);	    System.out.println("startIndex = " + startIndex);*/	    int q2Start = 0;	    //System.out.println("char = " + inputs[startChain].substring(startIndex,startIndex + 1));	    while(!inputs[startChain].substring(startIndex,startIndex + 1).matches("[A-Z]")) {// while tail doesn't start with a capital letter	       startIndex = (int)(Math.random() * lengths[startChain]); // try another starting spot	    }	        	    q1 = inputs[startChain].substring(startIndex, startIndex + k); // the tail character-chunk of the output string	    				    int activeChain = startChain; // numerical attempt at switching active chains	    String tail = "@";		 	    while (!spliced) { // build q1, the first half up to the liason k-gram			if (inputs[(activeChain + 1) % 2].contains(tail) && ((int)(Math.random() * 100)) % c == 0) { // if the latest node ends in a short k-gram that also exists in the dormant chain...					 // and stochastically determine whether to swap chains based on phase constant						spliced = true;						//q1+="*";						//System.out.println("Splice!");						activeChain = (activeChain + 1) % 2; // swap active and dormant chains by toggling between 1 and 2 (can go up to N for any combination of N chains)						q2Start = inputs[activeChain].indexOf(tail) + tail.length();											} // otherwise, if the dormant chain lacks an analogue to the present node, keep calm and carry on with the present active chain			else {				tail = inputs[activeChain].substring(startIndex + q1.length(),startIndex + q1.length() + k + (int)(Math.random() * 2) - 1);				//System.out.print(tail + " ");				q1 += tail;				if(q1.contains("}")) { // if q1 has already run through a full quote without successfully splicing...					q1 = "";				}			}	    }	    System.out.println("q1 = " + q1);	    	    while(!q2.contains("}")) {// until q2 contains end-quote delimiter "}"...	    	//q2 = inputs[activeChain].subSequence(q2Start, inputs[activeChain].indexOf(arg0, arg1));	    	String qt = "";	    	for(int i = 0; !qt.contains("}"); i++) {	    		qt = inputs[activeChain].substring(q2Start + q2.length(),q2Start + i);	    		q2 += qt;	    	}	    }		 		 return q1 + q2;	}	// file reader method	/*public String readTextFile(String fullPathFilename) throws IOException {		StringBuffer sb = new StringBuffer(1024);		BufferedReader reader = new BufferedReader(new FileReader(fullPathFilename));						char[] chars = new char[1024];		int numRead = 0;		while( (numRead = reader.read(chars)) > -1){			sb.append(String.valueOf(chars));			}		reader.close();		return sb.toString();	}*/}